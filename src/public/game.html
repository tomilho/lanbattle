<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>

    html, body {
      margin: 0;
      padding: 0;      
    }
    
    canvas {
      display: block;
      margin: 0;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: gray;
    }

    .info {
      position: fixed;
      z-index: 1001;
    }

    canvas {
      position: fixed;
      z-index: 1000;
    }
  </style>
</head>

<body>
  <div class="info">
    <span id="ping">Waiting for connection</span>
  </div>
  <script>

    class Render {
      static DISPLAY = 1;
      static CONTROLLER = 2;
      #renderType;
      #canvas;
      #ctx;

      constructor(renderType) {
        switch (renderType) {
          case Render.DISPLAY:
            this.#initDisplay();
            break;
          case Render.CONTROLLER:
            this.#initController();
            break;
          default:
            throw new Error('Unknown Render Type');
        }
        this.#renderType = renderType;
      }

      /**
       * Used in LAN, WAN and MAN.
       * */
      #initDisplay() {
        this.#canvas = document.createElement('canvas');
        const ctx = this.#canvas.getContext('2d');
        this.#ctx = ctx;
        document.body.appendChild(this.#canvas);

      }

      /**
       * Must be used by players in LAN. 
       * Optional in WAN and MAN. 
       * */
      #initController() {

      }
      
      
      /**
       * Draws dynamic elements - tanks, bombs
       *
       * @see #initDisplay - Static elements are 
       * drawn once when the display is initialized.
      */ 
      draw(state) {
        // Skips drawing if this device is tasked to be a controller.
        if (this.#renderType === Render.CONTROLLER) { return; }
        // Checks if some resizing is needed
        if(!this.#resize()) {
          const canvas = this.#canvas;
          this.#ctx.fillRect(0,0, canvas.width, canvas.height);
          this.#ctx.beginPath();

        }
        
        this.map(0);
        // Draws the tanks position
        const tanks = state.tanks;
        for(const tank of tanks) {
          this.tank(tank);
        }
      }

      tank(tank) {
        const ctx = this.#ctx;
        const path = new Path2D();
        const [body, turret] = tank.getMesh();
        const scale = 25;
        // Draws the Body
        path.moveTo(tank.getPosition().x + body[0][0]*scale, 
                    tank.getPosition().y + body[0][1]*scale);
        for(let i = 1; i < body.length; i++) {
          path.lineTo(tank.getPosition().x + body[i][0]*scale, 
                      tank.getPosition().y + body[i][1]*scale);
        }
        
        path.closePath();
        // Adds Paths into the canvas
        ctx.fillStyle = 'blue';
        ctx.fill(path);
        ctx.lineWidth = 2;
        ctx.strokeStyle = 'yellow';
        ctx.stroke(path);
      }

      map(mapId) {
        const map = GameMaps[mapId];
        const ctx = this.#ctx;
        ctx.strokeStyle = 'black ';
        // Set line width
        ctx.lineWidth = 20;
        ctx.beginPath();
        // Boundary Walls
        for(const wall of GameMaps.boundaryWalls) {
          const [start, end] = wall;
          ctx.moveTo(start[0]*GameMaps.size.x, start[1]* GameMaps.size.y);
          ctx.lineTo(end[0]*GameMaps.size.x, end[1]* GameMaps.size.y);
        }
        ctx.stroke();

        // Inner Walls
        ctx.lineWidth = 30;
        ctx.beginPath();
        for(const wall of map) {
          const [start, end] = wall;
          ctx.moveTo(start[0]*GameMaps.size.x, start[1]* GameMaps.size.y);
          ctx.lineTo(end[0]*GameMaps.size.x, end[1]* GameMaps.size.y);
        }
        ctx.stroke();
      }

      #resize() {
        const canvas = this.#canvas;
        //if(canvas.style.height.startsWith(innerHeight.toString()) && canvas.style.width.startsWith(innerWidth.toString())) {
        //  return false;
        //}
        const dpr = devicePixelRatio;

        canvas.width = GameMaps.size.x * dpr;
        canvas.height = GameMaps.size.y * dpr;

        this.#ctx.scale(dpr, dpr)
        const scaleX = innerWidth / GameMaps.size.x;
        const scaleY = innerHeight / GameMaps.size.y;
        const scaleToFit = Math.min(scaleX, scaleY);

        canvas.style.height = GameMaps.size.y * scaleToFit + 'px';
        canvas.style.width = GameMaps.size.x * scaleToFit + 'px';
        return true;
      }

    }

    class Client {
      #state;#socket;
      #render;
      #isReady;
      #messageQueue;
      #input;
      #clientHz;
      constructor(hz) {
        this.#socket = new WebSocket(`${location.origin.replace(/^http/, 'ws')}${location.pathname}`);
        this.#clientHz = hz;
        this.#messageQueue = [];
        this.#input = {
          last_ts: undefined,
          interaction: undefined,
        };
        this.#render = null;
        this.#isReady = false;
        this.#state = {
          tanks: []
        };

        // Handles the newly connected session. 
        this.#handleSession();

      }

      /**
       * Update Cycle, aka main loop.
       * 
       * Each update cycle is coordinated with requestAnimationFrame.
       * The approach taken is an slight adaption of Gabriel Gambetta's update().
       * 
       * @see https://www.gabrielgambetta.com/client-prediction-live-demo.html
       * */
      update() {
        this.#processMessages();
        // Waits until the client is ready.
        if (this.#isReady) {
          this.#processInput();
          this.#render.draw(this.#state);
        }
        requestAnimationFrame(() => this.update());
      }

      /**
       * Handles websocket communication. 
       * Messages are delegated to X function.
      */
      async #handleSession() {
        const onMessage = async (event) => this.#messageQueue.push(event.data);
        const onOpen = (event) => {
          // Sends init message
          this.#socket.send('init');      
        }
        const onClose = (event) => {
          console.log('connection lost')
        }
        const onError = (event) => {
          console.log(event)
        }

        this.#socket.addEventListener('open', onOpen);
        this.#socket.addEventListener('message', onMessage);
        this.#socket.addEventListener('close', onClose);
        this.#socket.addEventListener('error', onError);
      }

      /**
       * Non-blocking input handling. The input is constantly received
       * without blocking the main game loop through events and stored
       * in the client. Whenever the input is needed a simple read is done.
       * 
       * The input can be either keyboard or motion based. Preferance is 
       * given to motion.
       * */
      #handleInput() {
        // TODO: set which input to use (device or keyboard)
        
        this.#input.interaction = {
          w: false, 
          s: false,
          a: false,
          d: false,
          space: false,
        };
        const input = this.#input.interaction;
        // Keyboard Inputs for Keyboard users
        const onKeyUpOrDown = (event) => {
          switch(event.code) {
            case "KeyW": case "ArrowUp":
              input.w = (event.type === "keydown");
            break;
            case "KeyS": case "ArrowDown":
              input.s = event.type === "keydown";
              break;
            case "KeyA": case "ArrowLeft":
              input.a = event.type === "keydown";
              break;
            case "KeyD": case "ArrowRight":
              input.d = event.type === "keydown";
              break;
            case "Space":
              input.space = event.type === "space";
              break;
          }
        }
        
        window.onkeydown = window.onkeyup = onKeyUpOrDown;
        
        // Device-motion inputs for Mobile-controller users
      
      }

      
      #processInput() {
        const input = this.#input;
        const now_ts = Date.now();
        const last_ts = input.last_ts || now_ts;
        const dt_ts = (now_ts - last_ts) / 1000.0;
        input.last_ts = now_ts;

        const tickInput = {
          // Used in lag compensation
          timestamp: now_ts,
          // Used to know what was going on during this time
          press_time: dt_ts,
          // Used in prediction/reconciliation
          sequence_number: this.#input.sequence_number++,
          // Keyboard input
          keyboard: input.interaction,
          // Controller input
          controller: null,
        }

        // Client-side prediction as Keyboard
        this.#state.tanks[0].applyInputAsKeyboard(tickInput);

        
      }

      #sendState(){
      }

      /**
       * Processes the messages 
       * */
      #processMessages() {
        this.#messageQueue.forEach(msg => {
          switch (msg.type) {
            case "init":
              this.#render = new Render(msg.data.display);
              this.#state.tanks.push(new Tank(msg.data.tankID, msg.data.spawn));
              this.#handleInput();
              this.#isReady = true;
              break;
            case "error":
              // TODO: NOTIFY ERROR
              break;       
          }
        });

        this.#messageQueue = [];
      }

    }
    
    class Tank {
      #id;
      #position;
      #speed;

      constructor(tankID, spawn) {
        this.#position = spawn;
        this.#id = tankID;
        /** STATS **/
        this.#speed = 100 // ms-1
      }
      
      getPosition() {
        return this.#position;
      }

      applyInputAsKeyboard(input) {
        // Although W key is forward, drawing wise it goes towards 0.
        let yComponent = input.keyboard.s - input.keyboard.w;
        let xComponent = input.keyboard.d - input.keyboard.a;
        this.#position.x += input.press_time * this.#speed * xComponent;
        this.#position.y += input.press_time * this.#speed * yComponent;
      }
      /**
       * Path of the tank "mesh".
       * */
      getMesh() {
        return [
          // Body
          [[0,0], 
          [0.5,0],
          [0.5, 0.50],
          [1.5, 0.50],
          [1.5, 0],
          [2, 0],
          [2, 3.25],
          [0, 3.25]],
          // Turret
          []
        ]
      }
    }

    // Only one map for now...
    // Walls coordinates are normalized.
    const GameMaps = {
      size: { x:1600, y:900 },
      boundaryWalls: [
        [[0,0], [1,0]],
        [[1,0], [1,1]],
        [[0,1], [1,1]],
        [[0,1], [0,0]],
      ],
      0: [
        [[0.5, 0.5], [0.5, 0.8]]
        // Inner Walls

      ]
    }
    
    ;(function () {
        // Initializes the client
        const client = new Client(15);
        // Start the main loop
        requestAnimationFrame(() => client.update());
    })();


  </script>
</body>
